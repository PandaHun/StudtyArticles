# 08. 의존성 관리하기

## 01. 의존성 이해하기

### 변경과 의존성

- 실행 시점의 의존성
  - 의존하는 객체가 정상 동작하기 위해, 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점의 의존성
  - 의존 대상 객체가 변경될 경우 의존되는 객체도 함께 변경된다.
- 의존성은 단방향의 방향성을 가진다.
- 변경에 의한 영향의 전파 가능성을 암시하는 의존성

### 의존성 전이

- A가 B를 의존하고, B가 C를 의존한다면 A는 C를 자동적으로 의존하게 된다.
  - 변경될 가능성을 의미하기에 모두 전이 되는 것이 아니다.
- 직접 의존하는 직접 의존성과 전이의 영향으로 전파되는 간접 의존성

### 컨텍스트 독립성

- **클래스가 사용될 특정한 문맥에 대해 최소한의 가정으로 이뤄져** 다른 문맥에서의 재사용이 수월 해지는 것
- 자신이 실행될 문맥에 대해 구체적인 정보를 가장 적게 알도록

### 의존성 해결하기

- 컴파일 타임 의존성은 구체적인 런타임 의존성으로 대체되어야 한다.

  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결

  - 객체 생성 후 

    ```
    setter
    ```

     메서드를 통해 의존성 해결

    - 설계를 좀 더 유연하게 만든다.
    - 객체를 생성하고 협력에 대한 상대를 정하기 때문에 정하기 전 까지의 상태가 불안정하다.

  - 메서드 실행 시 인자를 이용해 의존성 해결

- 그래서 생성자 + 

  ```
  setter
  ```

  - 완전한 상태의 객체를 생성한 후, 필요에 따라 `setter`로 의존 대상을 변경할 수 있다.

## 02. 유연한 설계

### 의존성과 결합도

- 협력을 하기 위해서 서로의 존재, 수행 가능한 책임을 알아야 하고, 의존성을 만들어 낸다.

  - 의존성이 나쁜 것은 아니나, 과하면 문제가 됨

- 의존성의 존재가 아니라 의존성의 정도가 중요하다.

  - 낮은 의존성으로 재사용성을 높여야 한다.

- 바람직한 의존성은 

  재사용성

  과 관련 있다.

  - 다양한 환경에서 재사용이 불가능하다? ⇒ 바람직 하지 못하다
  - 특정 문맥에 강하게 의존하는 클래스를 다시 사용하려면 구현을 바꿔야 함

- 의존성과 결합도

- 의존성은 존재를 나타내고, 결합도는 의존성의 정도를 나타낸다

### 지식이 결합을 낳는다

- 객체가 다른 객체에 대해 서로 알고 있는 지식의 양이 결합도를 나타낸다
- 더 많이 알수록 더 많이 결합되고, 더 제한된 문맥에서 재사용 가능함을 나타낸다.
  - 협력하는 대상에 대해 필요한 정보 외에는 감추는 행동이 필요하다.
  - 이를 해결하기 위한 방법은 **추상화**

### 추상화에 의존하라

- 추상화, 결합도 관점에서의 의존 대상
  - 구체 클래스 의존성
  - 추상 클래스 의존성
    - 다만 상속에 대해 알고 있어야 함.
  - 인터페이스 의존성
- 실행 문맥에 대해 알아야 하는 정보를 줄일 수록 결합도가 낮아진다.

### 명시적인 의존성

- 의존의 대상을 생성자의 인자로 받거나 직접 생성자 안에서 생성하는 방법의 차이는 퍼블릭 인터페이스로 설정할 수 있는 방법을 제공하는 지의 차이
  - 생성자의 인자로 받는 것은, 의존을 인터페이스에 드러낸다.
    - 주로 `setter`, 메서드의 인자를 사용하는 방식.
  - 이를 명시적인 의존성
  - 생성자 안에서 생성하는 방법은 의존 사실을 감춘다.
  - 이를 숨겨진 의존성이라 한다.
- 의존성이 명시적이지 않다면, 구현을 들여다 봐야 한다.
  - 더 큰 문제는 재사용을 위해서는 내부 구현을 바꿔야 한다.
  - 유연하고 재사용 가능한 설계는 의존성이 명시적으로 들어나는 설계

### new는 해롭다

- ```
  new
  ```

  를 잘못 사용하면 결합도가 극단적으로 높아진다.

  - 구체 클래스의 이름을 기술해야 한다. 추상화가 아닌 구체 클래스에 의존할 수 밖에 없음
  - 어떤 인자를 이용해 클래스의 생성자를 호출 하는지도 알아야 한다.

- 이를 해결하기 위해, 인스턴스 생성 로직과 인스턴스 사용 로직을 분리하는 것

- 사용과 생성의 책임을 분리, 의존성을 명시적으로 표현하고, 추상 클래스, 인터페이스를 의존하게 해 설계를 유연하게 한다.

### 가끔은 생성해도 무방하다.

- 협력하는 기본 객체를 설정하고 싶은 경우는 클래스 안에서 객체를 직접 생성하는 방식이 유용하다.
  - 만약 클라이언트로 옮긴다면, 반복적인 코드가 늘어나고, 사용성 또한 나빠진다.
- 하지만 이 또한 설계의 산물

### 표준 클래스에 대한 의존은 해롭지 않다.

- 의존성이 불편한 이유는 변경에 대한 암시가 존재한다.
- 하지만 변경 확률이 적은 클래스는 문제가 되지 않는다.
  - 바로 **표준 클래스**

# 09. 유연한 설계

## 01. 개방-폐쇄 원칙

- 확장에 대해서는 열려 있고, 수정에 대해서는 닫혀 있어야 한다.
  - 새로운 동작을 추가해 기능을 확장할 수 있다.
  - 기존의 코드를 수정하지 않고도 동작을 추가하거나 변경할 수 있다.

### 추상화가 핵심이다

- OCP의 핵심은 **추상화**
- OCP 관점에서 생략되지 않고 남겨진 부분은 공통점을 반영한 추상화의 결과
  - 공통 부분은 문맥이 바뀌어도 변하지 않아야 한다.
  - **수정에 닫혀 있다.**
- OCP를 가능하게 하는 것은 의존성의 방향이다.
  - 추상화를 했다고 수정에 대해 닫혀 있는 설계는 아니다.
- 명시적 의존성, 의존성 해결 등을 통해 컴파일 타임 의존성을 런타임 의존성으로 대체한다.
  - OCP를 따르는 코드를 만드는데 중요하지만, 핵심은 추상화

## 생성 사용 분리

- 결합도가 높아질 수록 OCP를 따르는 구조를 설계하기 어렵다.
  - 객체 생성에 대한 지식은 과도한 결합도를 초래한다.
- 객체의 생성을 피할 수는 없지만, 부적절한 곳에서의 생성이 문제다.
- 메시지를 전송하지 않고, 객체를 생성한다면 문제는 없다.
  - 아니면, 객체를 생성하지 않고 메세지만 전송했다면 괜찮았을 것.
  - 동일 코드 안에서 생성과 사용이 공존한 것이 문제다
- 사용과 생성의 분리의 가장 편한 방법
  - 객체 생성의 책임을 클라이언트에게 옮기는 것.
  - `Movie`의 클라이언트가 적절한 `DiscountPolicy`를 생성해 `Movie`에 전달하는 것

### FACTORY 추가하기

- 생성 책임을 클라이언트에게 보낸 것은, 

  ```
  Moive
  ```

  는 특정 문맥에 묶여서는 안되지만, 클라이언트는 상관이 없다는 전제.

  - 하지만 클라이언트도 문맥에 묶이지 않아야 한다면?

- 객체 생성과 관련된 지식을 클라이언트, 클라이언트와 협력하는 다른 클라이언트까지 세어나가기를 원치 않는다

  - 객체 생성과 관련된 책임을 전담하는 다른 객체를 추가하고, 사용하게 한다.
  - 이런 객체 생성에 특화된 객체를 FACTORY라 한다.

### 순수한 가공물에게 책임 할당하기

- Factory는 도메인 모델에 속하지 않는다.
  - 순수한 기술적인 결정이다.
  - 도메인 개념의 객체 생성 책임을 별도의 객체로 이동 시킨 것.
- 객체를 분해하는 표현적 분해와 행위적 분해
  - 표현적 분해: 도메인 개념을 표현하는 객체로 시스템을 분해하는 것.
    - 도메인 모델을 따르며, 도메인과 소프트웨어 사이의 표현적 차이를 최소화 하는 것
    - 객체 지향의 기본
  - 책임을 할당하기 위해 창조되는 도메인과 무관한 객체를 **순수한 가공물**이라고 한다.
  - 어떤 행동을 추가하려 하지만 마땅한 객체가 없다면, 순수 가공물을 추가해 책임을 할당하라.
    - 따라서, 표현적 분해보단 행위적 분해에서 생성되는 것이 일반적.

## 03. 의존성 주입

- 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법

  - 생성자 주입

  - ```
    setter
    ```

     주입

    - 언제라도 의존 대상을 교체할 수 있다.
    - 객체가 올바르게 생성되기 위해 어떤 의존성이 필수인지 표현 할 수 없다

  - 메서드 주입

    - 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용

### 숨겨진 의존성은 나쁘다

- 의존성 주입 외 의존성을 해결하는 다양한 방법

- 대표적으로 

  ```
  SERVICE LOCATOR 패턴
  ```

  - 의존성을 보관하는 일종의 저장소
  - 하지만, 의존성을 감춘다는 큰 단점이 있다.
    - 의존성을 이해하기 위해 코드를 들여다 봐야 한다.
    - 또한 컴파일 시점이 아닌 런타임 시점에 오류를 찾을 수 있다.

## 04. 의존성 역전 원칙

### 추상화와 의존성 역전

- 객체 사이의 협력의 본질을 담고 있는 것은 상위 수준의 정책

  - 하지만 상위 수준 클래스가 하위 수준 클래스에 의존한다면?
  - 하위 수준의 변경에 상위 클래스가 영향을 받는다.

- 의존성은 변경의 전파를 관련된 것.

  - 변경의 영향을 줄이기 위해 의존성을 관리해야 한다.

- 이를 위한 해결 또한 

  추상화

  - 상위, 하위 모두 추상화에 의존하도록 하면 된다.

- 의존성 역전 원칙

  1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 모두 추상화에 의존해야 한다.
  2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

## 05. 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다